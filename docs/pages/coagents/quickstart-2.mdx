import { Steps } from 'nextra/components'
import { CoAgentsFeatures } from "@/components";


# Getting Started with CoAgents


<CoAgentsFeatures.Toggle />

<CoAgentsFeatures.GenerativeUi>
  ### Generative UI

  Generative UI allows you to create dynamic user interfaces with AI-generated components.

  ```tsx
  useCoAgentAction({
    // the name of the agent 
    name: "car_rental_agent",
    
    // this is optional: the node name to render generative UI for. If left empty, renders for every node.
    nodeName: "confirm_node",
    
    // render can be a function or a string, just like useCopilotAction
    render: ({ state, status }) => {
      if (status === "inProgress") {
        return <div> Generating response: {state.response} </div>
      } else {
        return <div> Done generating response </div>
      }
    }
  });
  ```

</CoAgentsFeatures.GenerativeUi>

<CoAgentsFeatures.StreamAgentState>
  <Steps>
    ### Frontend

    All you need to do to get the current LangGraph agent state is call `useCoAgent`.

    ```tsx
    const { state } = useCoAgent({
      name: "search_agent", // the name of the agent
    });
    ```

    ### LangGraph
    The LangGraph state only updates when leaving a LangGraph node.
    If you want to stream state updates to the frontend as they are generated, you can do so by one of the following methods:

    #### Intercept tool calls

    If you would like to stream **intermediate** state to the frontend, you can do so by treating (streaming) tool call arguments as intermediate state:

    ```python
    # in python code:
    config = copilotkit_customize_config(
        config,
        emit_intermediate_state=[
            {
                "state_key": "steps", # key on the LangGraph state to be updated
                "tool": "search", # tool call 
                "tool_argument": "steps" # argument of the tool call interpreted as intermediate state
            },
        ]
    )

    # ...

    response = await ChatOpenAI(model="gpt-4").bind_tools([search_tool], parallel_tool_calls=False, tool_choice="search").ainvoke([
        *state["messages"],
        SystemMessage(
            content=system_message
        )
    ], config)
    ```

    #### Manually Emit State

    You can imperatively emit state by calling `copilotkit_emit_state`:

    ```python
    # imperative function:
    copilotkit_emit_state({"key": value}, config)
    ```

  </Steps>
</CoAgentsFeatures.StreamAgentState>

<CoAgentsFeatures.ShareAgentState>

  ### Share Agent State

  Sharing agent state allows for collaboration and persistence across different sessions or users. Here's how you can implement this feature:

  ```typescript
  const { state, setState, start, stop, run } = useCoAgent({
    name: "search_agent",
  });
  
  // ...
  setState(newStateEditedByUser)
  run("the user has updated the state") // optionally provide a hint about why the agent state changed.
  ```

  Just like before, we use the `state` variable on `useCoAgent` to receive the latest agent state.
  Now we additionally intercept 4 more of `useCoAgent`'s returned values:
  - `setState`: A function to update the agent's state manually
  - `start`: A function to initiate the agent's execution
  - `stop`: A function to halt the agent's execution
  - `run`: A function to re-run the agent, after updating the state. Optionally include a hint for why the state changed.


</CoAgentsFeatures.ShareAgentState>

<CoAgentsFeatures.AgentQAndA>
  ### Agent Q&A

  Coming soon.
</CoAgentsFeatures.AgentQAndA>
